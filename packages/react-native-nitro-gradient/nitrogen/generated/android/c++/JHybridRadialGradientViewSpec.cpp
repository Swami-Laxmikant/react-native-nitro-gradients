///
/// JHybridRadialGradientViewSpec.cpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#include "JHybridRadialGradientViewSpec.hpp"

// Forward declaration of `VectorR` to properly resolve imports.
namespace margelo::nitro::gradient { struct VectorR; }

#include <vector>
#include <optional>
#include "VectorR.hpp"
#include "JVectorR.hpp"
#include <string>
#include <variant>
#include "JVariant_String_Double.hpp"

namespace margelo::nitro::gradient {

  jni::local_ref<JHybridRadialGradientViewSpec::jhybriddata> JHybridRadialGradientViewSpec::initHybrid(jni::alias_ref<jhybridobject> jThis) {
    return makeCxxInstance(jThis);
  }

  void JHybridRadialGradientViewSpec::registerNatives() {
    registerHybrid({
      makeNativeMethod("initHybrid", JHybridRadialGradientViewSpec::initHybrid),
    });
  }

  size_t JHybridRadialGradientViewSpec::getExternalMemorySize() noexcept {
    static const auto method = javaClassStatic()->getMethod<jlong()>("getMemorySize");
    return method(_javaPart);
  }

  void JHybridRadialGradientViewSpec::dispose() noexcept {
    static const auto method = javaClassStatic()->getMethod<void()>("dispose");
    method(_javaPart);
  }

  // Properties
  std::vector<double> JHybridRadialGradientViewSpec::getColors() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JArrayDouble>()>("getColors");
    auto __result = method(_javaPart);
    return [&]() {
      size_t __size = __result->size();
      std::vector<double> __vector(__size);
      __result->getRegion(0, __size, __vector.data());
      return __vector;
    }();
  }
  void JHybridRadialGradientViewSpec::setColors(const std::vector<double>& colors) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JArrayDouble> /* colors */)>("setColors");
    method(_javaPart, [&]() {
      size_t __size = colors.size();
      jni::local_ref<jni::JArrayDouble> __array = jni::JArrayDouble::newArray(__size);
      __array->setRegion(0, __size, colors.data());
      return __array;
    }());
  }
  std::optional<std::vector<double>> JHybridRadialGradientViewSpec::getPositions() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JArrayDouble>()>("getPositions");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional([&]() {
      size_t __size = __result->size();
      std::vector<double> __vector(__size);
      __result->getRegion(0, __size, __vector.data());
      return __vector;
    }()) : std::nullopt;
  }
  void JHybridRadialGradientViewSpec::setPositions(const std::optional<std::vector<double>>& positions) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JArrayDouble> /* positions */)>("setPositions");
    method(_javaPart, positions.has_value() ? [&]() {
      size_t __size = positions.value().size();
      jni::local_ref<jni::JArrayDouble> __array = jni::JArrayDouble::newArray(__size);
      __array->setRegion(0, __size, positions.value().data());
      return __array;
    }() : nullptr);
  }
  std::optional<VectorR> JHybridRadialGradientViewSpec::getCenter() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JVectorR>()>("getCenter");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt;
  }
  void JHybridRadialGradientViewSpec::setCenter(const std::optional<VectorR>& center) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JVectorR> /* center */)>("setCenter");
    method(_javaPart, center.has_value() ? JVectorR::fromCpp(center.value()) : nullptr);
  }
  std::optional<std::variant<std::string, double>> JHybridRadialGradientViewSpec::getRadius() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JVariant_String_Double>()>("getRadius");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt;
  }
  void JHybridRadialGradientViewSpec::setRadius(const std::optional<std::variant<std::string, double>>& radius) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JVariant_String_Double> /* radius */)>("setRadius");
    method(_javaPart, radius.has_value() ? JVariant_String_Double::fromCpp(radius.value()) : nullptr);
  }

  // Methods
  void JHybridRadialGradientViewSpec::update(const std::optional<std::vector<double>>& colors, const std::optional<std::vector<double>>& positions, const std::optional<VectorR>& center, const std::optional<std::variant<std::string, double>>& radius) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JArrayDouble> /* colors */, jni::alias_ref<jni::JArrayDouble> /* positions */, jni::alias_ref<JVectorR> /* center */, jni::alias_ref<JVariant_String_Double> /* radius */)>("update");
    method(_javaPart, colors.has_value() ? [&]() {
      size_t __size = colors.value().size();
      jni::local_ref<jni::JArrayDouble> __array = jni::JArrayDouble::newArray(__size);
      __array->setRegion(0, __size, colors.value().data());
      return __array;
    }() : nullptr, positions.has_value() ? [&]() {
      size_t __size = positions.value().size();
      jni::local_ref<jni::JArrayDouble> __array = jni::JArrayDouble::newArray(__size);
      __array->setRegion(0, __size, positions.value().data());
      return __array;
    }() : nullptr, center.has_value() ? JVectorR::fromCpp(center.value()) : nullptr, radius.has_value() ? JVariant_String_Double::fromCpp(radius.value()) : nullptr);
  }

} // namespace margelo::nitro::gradient
