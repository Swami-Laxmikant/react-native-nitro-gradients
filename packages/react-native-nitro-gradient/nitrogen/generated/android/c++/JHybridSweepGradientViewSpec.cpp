///
/// JHybridSweepGradientViewSpec.cpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#include "JHybridSweepGradientViewSpec.hpp"

// Forward declaration of `VectorR` to properly resolve imports.
namespace margelo::nitro::gradient { struct VectorR; }

#include <vector>
#include <optional>
#include "VectorR.hpp"
#include "JVectorR.hpp"
#include <string>
#include <variant>
#include "JVariant_String_Double.hpp"

namespace margelo::nitro::gradient {

  jni::local_ref<JHybridSweepGradientViewSpec::jhybriddata> JHybridSweepGradientViewSpec::initHybrid(jni::alias_ref<jhybridobject> jThis) {
    return makeCxxInstance(jThis);
  }

  void JHybridSweepGradientViewSpec::registerNatives() {
    registerHybrid({
      makeNativeMethod("initHybrid", JHybridSweepGradientViewSpec::initHybrid),
    });
  }

  size_t JHybridSweepGradientViewSpec::getExternalMemorySize() noexcept {
    static const auto method = javaClassStatic()->getMethod<jlong()>("getMemorySize");
    return method(_javaPart);
  }

  void JHybridSweepGradientViewSpec::dispose() noexcept {
    static const auto method = javaClassStatic()->getMethod<void()>("dispose");
    method(_javaPart);
  }

  // Properties
  std::vector<double> JHybridSweepGradientViewSpec::getColors() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JArrayDouble>()>("getColors");
    auto __result = method(_javaPart);
    return [&]() {
      size_t __size = __result->size();
      std::vector<double> __vector(__size);
      __result->getRegion(0, __size, __vector.data());
      return __vector;
    }();
  }
  void JHybridSweepGradientViewSpec::setColors(const std::vector<double>& colors) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JArrayDouble> /* colors */)>("setColors");
    method(_javaPart, [&]() {
      size_t __size = colors.size();
      jni::local_ref<jni::JArrayDouble> __array = jni::JArrayDouble::newArray(__size);
      __array->setRegion(0, __size, colors.data());
      return __array;
    }());
  }
  std::optional<std::vector<double>> JHybridSweepGradientViewSpec::getPositions() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JArrayDouble>()>("getPositions");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional([&]() {
      size_t __size = __result->size();
      std::vector<double> __vector(__size);
      __result->getRegion(0, __size, __vector.data());
      return __vector;
    }()) : std::nullopt;
  }
  void JHybridSweepGradientViewSpec::setPositions(const std::optional<std::vector<double>>& positions) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JArrayDouble> /* positions */)>("setPositions");
    method(_javaPart, positions.has_value() ? [&]() {
      size_t __size = positions.value().size();
      jni::local_ref<jni::JArrayDouble> __array = jni::JArrayDouble::newArray(__size);
      __array->setRegion(0, __size, positions.value().data());
      return __array;
    }() : nullptr);
  }
  std::optional<VectorR> JHybridSweepGradientViewSpec::getCenter() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JVectorR>()>("getCenter");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt;
  }
  void JHybridSweepGradientViewSpec::setCenter(const std::optional<VectorR>& center) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JVectorR> /* center */)>("setCenter");
    method(_javaPart, center.has_value() ? JVectorR::fromCpp(center.value()) : nullptr);
  }
  std::optional<double> JHybridSweepGradientViewSpec::getStartAngle() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JDouble>()>("getStartAngle");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->value()) : std::nullopt;
  }
  void JHybridSweepGradientViewSpec::setStartAngle(std::optional<double> startAngle) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JDouble> /* startAngle */)>("setStartAngle");
    method(_javaPart, startAngle.has_value() ? jni::JDouble::valueOf(startAngle.value()) : nullptr);
  }
  std::optional<double> JHybridSweepGradientViewSpec::getEndAngle() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JDouble>()>("getEndAngle");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->value()) : std::nullopt;
  }
  void JHybridSweepGradientViewSpec::setEndAngle(std::optional<double> endAngle) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JDouble> /* endAngle */)>("setEndAngle");
    method(_javaPart, endAngle.has_value() ? jni::JDouble::valueOf(endAngle.value()) : nullptr);
  }

  // Methods
  void JHybridSweepGradientViewSpec::update(const std::optional<std::vector<double>>& colors, const std::optional<std::vector<double>>& positions, const std::optional<VectorR>& center, std::optional<double> startAngle, std::optional<double> endAngle) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JArrayDouble> /* colors */, jni::alias_ref<jni::JArrayDouble> /* positions */, jni::alias_ref<JVectorR> /* center */, jni::alias_ref<jni::JDouble> /* startAngle */, jni::alias_ref<jni::JDouble> /* endAngle */)>("update");
    method(_javaPart, colors.has_value() ? [&]() {
      size_t __size = colors.value().size();
      jni::local_ref<jni::JArrayDouble> __array = jni::JArrayDouble::newArray(__size);
      __array->setRegion(0, __size, colors.value().data());
      return __array;
    }() : nullptr, positions.has_value() ? [&]() {
      size_t __size = positions.value().size();
      jni::local_ref<jni::JArrayDouble> __array = jni::JArrayDouble::newArray(__size);
      __array->setRegion(0, __size, positions.value().data());
      return __array;
    }() : nullptr, center.has_value() ? JVectorR::fromCpp(center.value()) : nullptr, startAngle.has_value() ? jni::JDouble::valueOf(startAngle.value()) : nullptr, endAngle.has_value() ? jni::JDouble::valueOf(endAngle.value()) : nullptr);
  }

} // namespace margelo::nitro::gradient
