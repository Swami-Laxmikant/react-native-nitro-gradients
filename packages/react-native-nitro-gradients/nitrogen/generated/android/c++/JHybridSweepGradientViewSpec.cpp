///
/// JHybridSweepGradientViewSpec.cpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© Marc Rousavy @ Margelo
///

#include "JHybridSweepGradientViewSpec.hpp"

// Forward declaration of `Vector` to properly resolve imports.
namespace margelo::nitro::gradient { struct Vector; }

#include <vector>
#include <optional>
#include "Vector.hpp"
#include "JVector.hpp"
#include <string>
#include <variant>
#include "JVariant_String_Double.hpp"
#include <NitroModules/Null.hpp>
#include "JVariant_NullType_DoubleArray.hpp"
#include <NitroModules/JNull.hpp>

namespace margelo::nitro::gradient {

  jni::local_ref<JHybridSweepGradientViewSpec::jhybriddata> JHybridSweepGradientViewSpec::initHybrid(jni::alias_ref<jhybridobject> jThis) {
    return makeCxxInstance(jThis);
  }

  void JHybridSweepGradientViewSpec::registerNatives() {
    registerHybrid({
      makeNativeMethod("initHybrid", JHybridSweepGradientViewSpec::initHybrid),
    });
  }

  size_t JHybridSweepGradientViewSpec::getExternalMemorySize() noexcept {
    static const auto method = javaClassStatic()->getMethod<jlong()>("getMemorySize");
    return method(_javaPart);
  }

  bool JHybridSweepGradientViewSpec::equals(const std::shared_ptr<HybridObject>& other) {
    if (auto otherCast = std::dynamic_pointer_cast<JHybridSweepGradientViewSpec>(other)) {
      return _javaPart == otherCast->_javaPart;
    }
    return false;
  }

  void JHybridSweepGradientViewSpec::dispose() noexcept {
    static const auto method = javaClassStatic()->getMethod<void()>("dispose");
    method(_javaPart);
  }

  std::string JHybridSweepGradientViewSpec::toString() {
    static const auto method = javaClassStatic()->getMethod<jni::JString()>("toString");
    auto javaString = method(_javaPart);
    return javaString->toStdString();
  }

  // Properties
  std::vector<double> JHybridSweepGradientViewSpec::getColors() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JArrayDouble>()>("getColors");
    auto __result = method(_javaPart);
    return [&]() {
      size_t __size = __result->size();
      std::vector<double> __vector(__size);
      __result->getRegion(0, __size, __vector.data());
      return __vector;
    }();
  }
  void JHybridSweepGradientViewSpec::setColors(const std::vector<double>& colors) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JArrayDouble> /* colors */)>("setColors");
    method(_javaPart, [&]() {
      size_t __size = colors.size();
      jni::local_ref<jni::JArrayDouble> __array = jni::JArrayDouble::newArray(__size);
      __array->setRegion(0, __size, colors.data());
      return __array;
    }());
  }
  std::optional<std::vector<double>> JHybridSweepGradientViewSpec::getPositions() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JArrayDouble>()>("getPositions");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional([&]() {
      size_t __size = __result->size();
      std::vector<double> __vector(__size);
      __result->getRegion(0, __size, __vector.data());
      return __vector;
    }()) : std::nullopt;
  }
  void JHybridSweepGradientViewSpec::setPositions(const std::optional<std::vector<double>>& positions) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JArrayDouble> /* positions */)>("setPositions");
    method(_javaPart, positions.has_value() ? [&]() {
      size_t __size = positions.value().size();
      jni::local_ref<jni::JArrayDouble> __array = jni::JArrayDouble::newArray(__size);
      __array->setRegion(0, __size, positions.value().data());
      return __array;
    }() : nullptr);
  }
  std::optional<Vector> JHybridSweepGradientViewSpec::getCenter() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JVector>()>("getCenter");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt;
  }
  void JHybridSweepGradientViewSpec::setCenter(const std::optional<Vector>& center) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JVector> /* center */)>("setCenter");
    method(_javaPart, center.has_value() ? JVector::fromCpp(center.value()) : nullptr);
  }

  // Methods
  void JHybridSweepGradientViewSpec::update(const std::optional<std::variant<nitro::NullType, std::vector<double>>>& colors, const std::optional<std::vector<double>>& positions, const std::optional<Vector>& center) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JVariant_NullType_DoubleArray> /* colors */, jni::alias_ref<jni::JArrayDouble> /* positions */, jni::alias_ref<JVector> /* center */)>("update");
    method(_javaPart, colors.has_value() ? JVariant_NullType_DoubleArray::fromCpp(colors.value()) : nullptr, positions.has_value() ? [&]() {
      size_t __size = positions.value().size();
      jni::local_ref<jni::JArrayDouble> __array = jni::JArrayDouble::newArray(__size);
      __array->setRegion(0, __size, positions.value().data());
      return __array;
    }() : nullptr, center.has_value() ? JVector::fromCpp(center.value()) : nullptr);
  }

} // namespace margelo::nitro::gradient
