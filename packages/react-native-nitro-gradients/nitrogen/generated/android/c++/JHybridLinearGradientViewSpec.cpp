///
/// JHybridLinearGradientViewSpec.cpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© Marc Rousavy @ Margelo
///

#include "JHybridLinearGradientViewSpec.hpp"

// Forward declaration of `Vector` to properly resolve imports.
namespace margelo::nitro::gradient { struct Vector; }

#include <vector>
#include <optional>
#include "Vector.hpp"
#include "JVector.hpp"
#include <string>
#include <variant>
#include "JVariant_String_Double.hpp"
#include <NitroModules/Null.hpp>
#include "JVariant_NullType_DoubleArray.hpp"
#include <NitroModules/JNull.hpp>

namespace margelo::nitro::gradient {

  jni::local_ref<JHybridLinearGradientViewSpec::jhybriddata> JHybridLinearGradientViewSpec::initHybrid(jni::alias_ref<jhybridobject> jThis) {
    return makeCxxInstance(jThis);
  }

  void JHybridLinearGradientViewSpec::registerNatives() {
    registerHybrid({
      makeNativeMethod("initHybrid", JHybridLinearGradientViewSpec::initHybrid),
    });
  }

  size_t JHybridLinearGradientViewSpec::getExternalMemorySize() noexcept {
    static const auto method = javaClassStatic()->getMethod<jlong()>("getMemorySize");
    return method(_javaPart);
  }

  bool JHybridLinearGradientViewSpec::equals(const std::shared_ptr<HybridObject>& other) {
    if (auto otherCast = std::dynamic_pointer_cast<JHybridLinearGradientViewSpec>(other)) {
      return _javaPart == otherCast->_javaPart;
    }
    return false;
  }

  void JHybridLinearGradientViewSpec::dispose() noexcept {
    static const auto method = javaClassStatic()->getMethod<void()>("dispose");
    method(_javaPart);
  }

  std::string JHybridLinearGradientViewSpec::toString() {
    static const auto method = javaClassStatic()->getMethod<jni::JString()>("toString");
    auto javaString = method(_javaPart);
    return javaString->toStdString();
  }

  // Properties
  std::vector<double> JHybridLinearGradientViewSpec::getColors() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JArrayDouble>()>("getColors");
    auto __result = method(_javaPart);
    return [&]() {
      size_t __size = __result->size();
      std::vector<double> __vector(__size);
      __result->getRegion(0, __size, __vector.data());
      return __vector;
    }();
  }
  void JHybridLinearGradientViewSpec::setColors(const std::vector<double>& colors) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JArrayDouble> /* colors */)>("setColors");
    method(_javaPart, [&]() {
      size_t __size = colors.size();
      jni::local_ref<jni::JArrayDouble> __array = jni::JArrayDouble::newArray(__size);
      __array->setRegion(0, __size, colors.data());
      return __array;
    }());
  }
  std::optional<std::vector<double>> JHybridLinearGradientViewSpec::getPositions() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JArrayDouble>()>("getPositions");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional([&]() {
      size_t __size = __result->size();
      std::vector<double> __vector(__size);
      __result->getRegion(0, __size, __vector.data());
      return __vector;
    }()) : std::nullopt;
  }
  void JHybridLinearGradientViewSpec::setPositions(const std::optional<std::vector<double>>& positions) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JArrayDouble> /* positions */)>("setPositions");
    method(_javaPart, positions.has_value() ? [&]() {
      size_t __size = positions.value().size();
      jni::local_ref<jni::JArrayDouble> __array = jni::JArrayDouble::newArray(__size);
      __array->setRegion(0, __size, positions.value().data());
      return __array;
    }() : nullptr);
  }
  std::optional<Vector> JHybridLinearGradientViewSpec::getStart() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JVector>()>("getStart");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt;
  }
  void JHybridLinearGradientViewSpec::setStart(const std::optional<Vector>& start) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JVector> /* start */)>("setStart");
    method(_javaPart, start.has_value() ? JVector::fromCpp(start.value()) : nullptr);
  }
  std::optional<Vector> JHybridLinearGradientViewSpec::getEnd() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JVector>()>("getEnd");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt;
  }
  void JHybridLinearGradientViewSpec::setEnd(const std::optional<Vector>& end) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JVector> /* end */)>("setEnd");
    method(_javaPart, end.has_value() ? JVector::fromCpp(end.value()) : nullptr);
  }
  std::optional<double> JHybridLinearGradientViewSpec::getAngle() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JDouble>()>("getAngle");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->value()) : std::nullopt;
  }
  void JHybridLinearGradientViewSpec::setAngle(std::optional<double> angle) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JDouble> /* angle */)>("setAngle");
    method(_javaPart, angle.has_value() ? jni::JDouble::valueOf(angle.value()) : nullptr);
  }

  // Methods
  void JHybridLinearGradientViewSpec::update(const std::optional<std::variant<nitro::NullType, std::vector<double>>>& colors, const std::optional<std::vector<double>>& positions, const std::optional<Vector>& start, const std::optional<Vector>& end, std::optional<double> angle) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JVariant_NullType_DoubleArray> /* colors */, jni::alias_ref<jni::JArrayDouble> /* positions */, jni::alias_ref<JVector> /* start */, jni::alias_ref<JVector> /* end */, jni::alias_ref<jni::JDouble> /* angle */)>("update");
    method(_javaPart, colors.has_value() ? JVariant_NullType_DoubleArray::fromCpp(colors.value()) : nullptr, positions.has_value() ? [&]() {
      size_t __size = positions.value().size();
      jni::local_ref<jni::JArrayDouble> __array = jni::JArrayDouble::newArray(__size);
      __array->setRegion(0, __size, positions.value().data());
      return __array;
    }() : nullptr, start.has_value() ? JVector::fromCpp(start.value()) : nullptr, end.has_value() ? JVector::fromCpp(end.value()) : nullptr, angle.has_value() ? jni::JDouble::valueOf(angle.value()) : nullptr);
  }

} // namespace margelo::nitro::gradient
