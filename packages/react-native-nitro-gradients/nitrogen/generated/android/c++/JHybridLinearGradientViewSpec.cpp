///
/// JHybridLinearGradientViewSpec.cpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#include "JHybridLinearGradientViewSpec.hpp"

// Forward declaration of `VectorR` to properly resolve imports.
namespace margelo::nitro::gradient { struct VectorR; }

#include <vector>
#include <optional>
#include "VectorR.hpp"
#include "JVectorR.hpp"
#include <string>
#include <variant>
#include "JVariant_String_Double.hpp"
#include <NitroModules/Null.hpp>
#include "JVariant_NullType_DoubleArray.hpp"
#include <NitroModules/JNull.hpp>

namespace margelo::nitro::gradient {

  jni::local_ref<JHybridLinearGradientViewSpec::jhybriddata> JHybridLinearGradientViewSpec::initHybrid(jni::alias_ref<jhybridobject> jThis) {
    return makeCxxInstance(jThis);
  }

  void JHybridLinearGradientViewSpec::registerNatives() {
    registerHybrid({
      makeNativeMethod("initHybrid", JHybridLinearGradientViewSpec::initHybrid),
    });
  }

  size_t JHybridLinearGradientViewSpec::getExternalMemorySize() noexcept {
    static const auto method = javaClassStatic()->getMethod<jlong()>("getMemorySize");
    return method(_javaPart);
  }

  void JHybridLinearGradientViewSpec::dispose() noexcept {
    static const auto method = javaClassStatic()->getMethod<void()>("dispose");
    method(_javaPart);
  }

  std::string JHybridLinearGradientViewSpec::toString() {
    static const auto method = javaClassStatic()->getMethod<jni::JString()>("toString");
    auto javaString = method(_javaPart);
    return javaString->toStdString();
  }

  // Properties
  std::vector<double> JHybridLinearGradientViewSpec::getColors() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JArrayDouble>()>("getColors");
    auto __result = method(_javaPart);
    return [&]() {
      size_t __size = __result->size();
      std::vector<double> __vector(__size);
      __result->getRegion(0, __size, __vector.data());
      return __vector;
    }();
  }
  void JHybridLinearGradientViewSpec::setColors(const std::vector<double>& colors) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JArrayDouble> /* colors */)>("setColors");
    method(_javaPart, [&]() {
      size_t __size = colors.size();
      jni::local_ref<jni::JArrayDouble> __array = jni::JArrayDouble::newArray(__size);
      __array->setRegion(0, __size, colors.data());
      return __array;
    }());
  }
  std::optional<std::vector<double>> JHybridLinearGradientViewSpec::getPositions() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<jni::JArrayDouble>()>("getPositions");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional([&]() {
      size_t __size = __result->size();
      std::vector<double> __vector(__size);
      __result->getRegion(0, __size, __vector.data());
      return __vector;
    }()) : std::nullopt;
  }
  void JHybridLinearGradientViewSpec::setPositions(const std::optional<std::vector<double>>& positions) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<jni::JArrayDouble> /* positions */)>("setPositions");
    method(_javaPart, positions.has_value() ? [&]() {
      size_t __size = positions.value().size();
      jni::local_ref<jni::JArrayDouble> __array = jni::JArrayDouble::newArray(__size);
      __array->setRegion(0, __size, positions.value().data());
      return __array;
    }() : nullptr);
  }
  std::optional<VectorR> JHybridLinearGradientViewSpec::getStart() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JVectorR>()>("getStart");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt;
  }
  void JHybridLinearGradientViewSpec::setStart(const std::optional<VectorR>& start) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JVectorR> /* start */)>("setStart");
    method(_javaPart, start.has_value() ? JVectorR::fromCpp(start.value()) : nullptr);
  }
  std::optional<VectorR> JHybridLinearGradientViewSpec::getEnd() {
    static const auto method = javaClassStatic()->getMethod<jni::local_ref<JVectorR>()>("getEnd");
    auto __result = method(_javaPart);
    return __result != nullptr ? std::make_optional(__result->toCpp()) : std::nullopt;
  }
  void JHybridLinearGradientViewSpec::setEnd(const std::optional<VectorR>& end) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JVectorR> /* end */)>("setEnd");
    method(_javaPart, end.has_value() ? JVectorR::fromCpp(end.value()) : nullptr);
  }

  // Methods
  void JHybridLinearGradientViewSpec::update(const std::optional<std::variant<nitro::NullType, std::vector<double>>>& colors, const std::optional<std::vector<double>>& positions, const std::optional<VectorR>& start, const std::optional<VectorR>& end) {
    static const auto method = javaClassStatic()->getMethod<void(jni::alias_ref<JVariant_NullType_DoubleArray> /* colors */, jni::alias_ref<jni::JArrayDouble> /* positions */, jni::alias_ref<JVectorR> /* start */, jni::alias_ref<JVectorR> /* end */)>("update");
    method(_javaPart, colors.has_value() ? JVariant_NullType_DoubleArray::fromCpp(colors.value()) : nullptr, positions.has_value() ? [&]() {
      size_t __size = positions.value().size();
      jni::local_ref<jni::JArrayDouble> __array = jni::JArrayDouble::newArray(__size);
      __array->setRegion(0, __size, positions.value().data());
      return __array;
    }() : nullptr, start.has_value() ? JVectorR::fromCpp(start.value()) : nullptr, end.has_value() ? JVectorR::fromCpp(end.value()) : nullptr);
  }

} // namespace margelo::nitro::gradient
